using Petecat.DependencyInjection;
using System;
using System.Linq;
using System.Collections.Concurrent;
using System.Reflection;
using System.Reflection.Emit;
using Petecat.DependencyInjection.Attributes;

namespace Petecat.DynamicProxy
{
    [DependencyInjectable(Inference = typeof(ITypeGenerator), Sington = true)]
    public class TypeGeneratorBase : ITypeGenerator
    {
        private AssemblyBuilder _AssemblyBuilder = null;

        private ModuleBuilder _ModuleBuilder = null;

        public TypeGeneratorBase()
        {
            _AssemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(new AssemblyName() { Name = "AutoGeneratedAopModule.dll" }, AssemblyBuilderAccess.RunAndSave);
            _ModuleBuilder = _AssemblyBuilder.DefineDynamicModule("AutoGeneratedAopModule", "AutoGeneratedAopModule.dll");
        }

        private ConcurrentDictionary<Type, Type> _GeneratedTypes = null;

        public ConcurrentDictionary<Type, Type> GeneratedTypes
        {
            get { return _GeneratedTypes ?? (_GeneratedTypes = new ConcurrentDictionary<Type, Type>()); }
        }

        public object CreateProxyObject(Type baseClass, IInterceptor interceptor)
        {
            return Activator.CreateInstance(CreateProxyType(baseClass), new object[] { interceptor });
        }

        public T CreateProxyObject<T>(IInterceptor interceptor)
        {
            return (T)CreateProxyObject(typeof(T), interceptor);
        }

        public Type CreateProxyType(Type baseClass)
        {
            if (!baseClass.IsClass)
            {
                // TODO: throw
            }

            if (!GeneratedTypes.ContainsKey(baseClass))
            {
                GeneratedTypes[baseClass] = InternalGenerate(baseClass);
            }

            return GeneratedTypes[baseClass];
        }

        private Type InternalGenerate(Type baseClass)
        {
            var typeBuilder = _ModuleBuilder.DefineType("DynamicProxy_" + baseClass.Name, TypeAttributes.Public, baseClass);

            var fieldBuilder = typeBuilder.DefineField("_Interceptor", typeof(IInterceptor), FieldAttributes.Private);

            var baseCtor = baseClass.GetConstructor(new Type[0]);
            var ctorBuilder = typeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new Type[] { typeof(IInterceptor) });
            var ctorIL = ctorBuilder.GetILGenerator();
            ctorIL.Emit(OpCodes.Ldarg_0);
            ctorIL.Emit(OpCodes.Call, baseCtor);
            ctorIL.Emit(OpCodes.Ldarg_0);
            ctorIL.Emit(OpCodes.Ldarg_1);
            ctorIL.Emit(OpCodes.Stfld, fieldBuilder);
            ctorIL.Emit(OpCodes.Ret);

            var objectMethods = typeof(object).GetMethods();

            foreach (var method in baseClass.GetMethods().Where(x => x.IsVirtual && !objectMethods.ToList().Exists(y => y.Name == x.Name)))
            {
                var parameterInfos = method.GetParameters();

                var methodBuilder = typeBuilder.DefineMethod(method.Name, method.Attributes,
                    method.ReturnType, method.GetParameters().Select(x => x.ParameterType).ToArray());

                ILGenerator mthdIL = methodBuilder.GetILGenerator();

                mthdIL.DeclareLocal(typeof(InvocationBase));
                mthdIL.Emit(OpCodes.Newobj, typeof(InvocationBase).GetConstructor(new Type[] { }));
                mthdIL.Emit(OpCodes.Stloc_0);

                mthdIL.DeclareLocal(baseClass);
                mthdIL.Emit(OpCodes.Newobj, baseClass.GetConstructor(new Type[] { }));
                mthdIL.Emit(OpCodes.Stloc_1);

                mthdIL.Emit(OpCodes.Ldloc_0);
                mthdIL.Emit(OpCodes.Ldloc_1);
                mthdIL.Emit(OpCodes.Callvirt, typeof(InvocationBase).GetMethod("set_Owner", new Type[] { typeof(object) }));

                mthdIL.Emit(OpCodes.Ldloc_0);
                mthdIL.Emit(OpCodes.Ldtoken, baseClass);
                mthdIL.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle", new Type[] { typeof(RuntimeTypeHandle) }));
                mthdIL.Emit(OpCodes.Ldstr, method.Name);

                mthdIL.Emit(OpCodes.Ldc_I4, parameterInfos.Length);
                mthdIL.Emit(OpCodes.Newarr, typeof(Type));
                for (int i = 0; i < parameterInfos.Length; i++)
                {
                    mthdIL.Emit(OpCodes.Dup);
                    mthdIL.Emit(OpCodes.Ldc_I4, i);
                    mthdIL.Emit(OpCodes.Ldtoken, parameterInfos[i].ParameterType);
                    mthdIL.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle", new Type[] { typeof(RuntimeTypeHandle) }));
                    mthdIL.Emit(OpCodes.Stelem_Ref);
                }

                mthdIL.Emit(OpCodes.Call, typeof(Type).GetMethod("GetMethod", new Type[] { typeof(string), typeof(Type[]) }));
                mthdIL.Emit(OpCodes.Callvirt, typeof(InvocationBase).GetMethod("set_Method", new Type[] { typeof(MethodInfo) }));

                mthdIL.Emit(OpCodes.Ldloc_0);
                mthdIL.Emit(OpCodes.Ldc_I4, parameterInfos.Length);
                mthdIL.Emit(OpCodes.Newarr, typeof(object));
                for (int i = 0; i < parameterInfos.Length; i++)
                {
                    mthdIL.Emit(OpCodes.Dup);
                    mthdIL.Emit(OpCodes.Ldc_I4, i);
                    mthdIL.Emit(OpCodes.Ldarg, i + 1);
                    mthdIL.Emit(OpCodes.Stelem_Ref);
                }
                mthdIL.Emit(OpCodes.Callvirt, typeof(InvocationBase).GetMethod("set_ParameterValues", new Type[] { typeof(object[]) }));

                mthdIL.Emit(OpCodes.Ldarg_0);
                mthdIL.Emit(OpCodes.Ldfld, fieldBuilder);
                mthdIL.Emit(OpCodes.Ldloc_0);
                mthdIL.Emit(OpCodes.Callvirt, typeof(IInterceptor).GetMethod("Intercept", new Type[] { typeof(IInvocation) }));

                if (method.ReturnType != typeof(void))
                {
                    mthdIL.Emit(OpCodes.Ldloc_0);
                    mthdIL.Emit(OpCodes.Callvirt, typeof(InvocationBase).GetMethod("get_ReturnValue", new Type[0]));
                    mthdIL.Emit(OpCodes.Isinst, method.ReturnType);
                }

                mthdIL.Emit(OpCodes.Ret);

                typeBuilder.DefineMethodOverride(methodBuilder, baseClass.GetMethod(method.Name, parameterInfos.Select(x => x.ParameterType).ToArray()));
            }

            var targetType = typeBuilder.CreateType();

            return targetType;
        }

        
    }
}
