using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Collections.Generic;

namespace Petecat.Aop
{
    internal class DefaultAopProxyTypeGenerator : IAopProxyTypeGenerator
    {
        private static DefaultAopProxyTypeGenerator _Instance = null;

        public static DefaultAopProxyTypeGenerator Instance { get { return _Instance ?? (_Instance = new DefaultAopProxyTypeGenerator()); } }

        private DefaultAopProxyTypeGenerator()
        {
            var assemblyName = new AssemblyName() { Name = "AutoGeneratedAopModule.dll" };

            _AssemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.RunAndSave);

            _ModuleBuilder = _AssemblyBuilder.DefineDynamicModule("AutoGeneratedAopModule", "AutoGeneratedAopModule.dll");
        }

        private AssemblyBuilder _AssemblyBuilder = null;

        private ModuleBuilder _ModuleBuilder = null;

        private Dictionary<string, Type> _AutoGeneratedTypes = null;

        public Dictionary<string, Type> AutoGeneratedTypes { get { return _AutoGeneratedTypes ?? (_AutoGeneratedTypes = new Dictionary<string, Type>()); } }
        
        public object GetProxyObject(Type baseClass, IAopInterceptor aopInterceptor)
        {
            return Activator.CreateInstance(GetProxyType(baseClass, aopInterceptor), new object[] { aopInterceptor });
        }

        public T GetProxyObject<T>(IAopInterceptor aopInterceptor)
        {
            return (T)GetProxyObject(typeof(T), aopInterceptor);
        }

        private Type GetProxyType(Type baseClass, IAopInterceptor interceptor)
        {
            var key = baseClass.FullName + "_" + interceptor.GetType().FullName;
            if (AutoGeneratedTypes.ContainsKey(key))
            {
                return AutoGeneratedTypes[key];
            }
            else
            {
                var autoGeneratedType = Generate(baseClass);
                AutoGeneratedTypes.Add(key, autoGeneratedType);
                return autoGeneratedType;
            }
        }

        private Type Generate(Type baseClass)
        {
            var typeBuilder = _ModuleBuilder.DefineType(GenerateClassName(baseClass), TypeAttributes.Public, baseClass);
            
            var fieldBuilder = typeBuilder.DefineField("_AopInterceptor", typeof(IAopInterceptor), FieldAttributes.Private);
            
            var baseCtor = baseClass.GetConstructor(new Type[0]);
            var ctorBuilder = typeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new Type[] { typeof(IAopInterceptor) });
            var ctorIL = ctorBuilder.GetILGenerator();
            ctorIL.Emit(OpCodes.Ldarg_0);
            ctorIL.Emit(OpCodes.Call, baseCtor);
            ctorIL.Emit(OpCodes.Ldarg_0);
            ctorIL.Emit(OpCodes.Ldarg_1);
            ctorIL.Emit(OpCodes.Stfld, fieldBuilder);
            ctorIL.Emit(OpCodes.Ret);

            var objectMethods = typeof(object).GetMethods();

            foreach (var method in baseClass.GetMethods().Where(x => x.IsVirtual && !objectMethods.ToList().Exists(y => y.Name == x.Name)))
            {
                var methodBuilder = typeBuilder.DefineMethod(method.Name, method.Attributes,
                    method.ReturnType, method.GetParameters().Select(x => x.ParameterType).ToArray());

                ILGenerator mthdIL = methodBuilder.GetILGenerator();
                
                mthdIL.DeclareLocal(typeof(DefaultAopInvocation));
                mthdIL.Emit(OpCodes.Newobj, typeof(DefaultAopInvocation).GetConstructor(new Type[] { }));
                mthdIL.Emit(OpCodes.Stloc_0);
                
                mthdIL.DeclareLocal(baseClass);
                mthdIL.Emit(OpCodes.Newobj, baseClass.GetConstructor(new Type[] { }));
                mthdIL.Emit(OpCodes.Stloc_1);
                
                mthdIL.Emit(OpCodes.Ldloc_0);
                mthdIL.Emit(OpCodes.Ldloc_1);
                mthdIL.Emit(OpCodes.Callvirt, typeof(DefaultAopInvocation).GetMethod("set_Owner", new Type[] { typeof(object) }));

                mthdIL.Emit(OpCodes.Ldloc_0);
                mthdIL.Emit(OpCodes.Ldtoken, baseClass);
                mthdIL.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle", new Type[] { typeof(RuntimeTypeHandle) }));
                mthdIL.Emit(OpCodes.Ldstr, method.Name);
                mthdIL.Emit(OpCodes.Call, typeof(Type).GetMethod("GetMethod", new Type[] { typeof(string) }));
                mthdIL.Emit(OpCodes.Callvirt, typeof(DefaultAopInvocation).GetMethod("set_Method", new Type[] { typeof(MethodInfo) }));

                mthdIL.Emit(OpCodes.Ldloc_0);
                mthdIL.Emit(OpCodes.Ldc_I4, method.GetParameters().Length);
                mthdIL.Emit(OpCodes.Newarr, typeof(object));
                for (int i = 0; i < method.GetParameters().Length; i++)
                {
                    mthdIL.Emit(OpCodes.Dup);
                    mthdIL.Emit(OpCodes.Ldc_I4, i);
                    mthdIL.Emit(OpCodes.Ldarg, i + 1);
                    mthdIL.Emit(OpCodes.Stelem_Ref);
                }
                mthdIL.Emit(OpCodes.Callvirt, typeof(DefaultAopInvocation).GetMethod("set_ParameterValues", new Type[] { typeof(object[]) }));

                mthdIL.Emit(OpCodes.Ldarg_0);
                mthdIL.Emit(OpCodes.Ldfld, fieldBuilder);
                mthdIL.Emit(OpCodes.Ldloc_0);
                mthdIL.Emit(OpCodes.Callvirt, typeof(IAopInterceptor).GetMethod("Intercept", new Type[] { typeof(IAopInvocation) }));

                mthdIL.DeclareLocal(method.ReturnType);
                mthdIL.Emit(OpCodes.Ldloc_0);
                mthdIL.Emit(OpCodes.Callvirt, typeof(DefaultAopInvocation).GetMethod("get_ReturnValue", new Type[0]));
                mthdIL.Emit(OpCodes.Isinst, method.ReturnType);

                mthdIL.Emit(OpCodes.Ret);

                typeBuilder.DefineMethodOverride(methodBuilder, baseClass.GetMethod(method.Name));
            }

            var targetType = typeBuilder.CreateType();

            return targetType;
        }

        private string GenerateClassName(Type baseClass)
        {
            return baseClass.Name + "_" + Path.GetRandomFileName().Replace(".", "").ToUpper();
        }
    }
}
