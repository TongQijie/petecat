using System;
using System.Linq;
using System.Collections.Concurrent;
using System.Reflection;
using System.Reflection.Emit;

using Petecat.DependencyInjection.Attributes;

namespace Petecat.DynamicProxy
{
    [DependencyInjectable(Inference = typeof(IDynamicProxyGenerator), Sington = true)]
    public class DynamicProxyGenerator : IDynamicProxyGenerator
    {
        private AssemblyBuilder _AssemblyBuilder = null;

        private ModuleBuilder _ModuleBuilder = null;

        public DynamicProxyGenerator()
        {
            _AssemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(new AssemblyName() { Name = "AutoGeneratedModule.dll" }, AssemblyBuilderAccess.Run);
            _ModuleBuilder = _AssemblyBuilder.DefineDynamicModule("AutoGeneratedModule");

            // DEBUG
            //_AssemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(new AssemblyName() { Name = "AutoGeneratedModule.dll" }, AssemblyBuilderAccess.RunAndSave);
            //_ModuleBuilder = _AssemblyBuilder.DefineDynamicModule("AutoGeneratedModule", "auto.dll");
        }

        private ConcurrentDictionary<Type, Type> _GeneratedTypes = null;

        public ConcurrentDictionary<Type, Type> GeneratedTypes
        {
            get { return _GeneratedTypes ?? (_GeneratedTypes = new ConcurrentDictionary<Type, Type>()); }
        }

        public object CreateProxyObject(Type baseClass, IInterceptor interceptor)
        {
            return Activator.CreateInstance(CreateProxyType(baseClass), new object[] { interceptor });
        }

        public T CreateProxyObject<T>(IInterceptor interceptor)
        {
            return (T)CreateProxyObject(typeof(T), interceptor);
        }

        public Type CreateProxyType(Type baseClass)
        {
            if (!baseClass.IsClass)
            {
                // TODO: throw
            }

            if (!GeneratedTypes.ContainsKey(baseClass))
            {
                GeneratedTypes[baseClass] = InternalGenerate(baseClass);
            }

            return GeneratedTypes[baseClass];
        }

        private Type InternalGenerate(Type baseClass)
        {
            var typeBuilder = _ModuleBuilder.DefineType("DynamicProxy_" + baseClass.Name, TypeAttributes.Public, baseClass);

            var fieldBuilder = typeBuilder.DefineField("_Interceptor", typeof(IInterceptor), FieldAttributes.Private);

            var baseCtor = baseClass.GetConstructor(new Type[0]);
            var ctorBuilder = typeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new Type[] { typeof(IInterceptor) });
            var ctorIL = ctorBuilder.GetILGenerator();
            ctorIL.Emit(OpCodes.Ldarg_0);
            ctorIL.Emit(OpCodes.Call, baseCtor);
            ctorIL.Emit(OpCodes.Ldarg_0);
            ctorIL.Emit(OpCodes.Ldarg_1);
            ctorIL.Emit(OpCodes.Stfld, fieldBuilder);
            ctorIL.Emit(OpCodes.Ret);

            var objectMethods = typeof(object).GetMethods();

            foreach (var method in baseClass.GetMethods().Where(x => x.IsVirtual && !objectMethods.ToList().Exists(y => y.Name == x.Name)))
            {
                var parameterInfos = method.GetParameters();
                var hasParameters = parameterInfos.Length > 0;
                var hasReturnValue = method.ReturnType != typeof(void);

                var methodBuilder = typeBuilder.DefineMethod(method.Name, method.Attributes,
                    method.ReturnType, method.GetParameters().Select(x => x.ParameterType).ToArray());

                ILGenerator mthdIL = methodBuilder.GetILGenerator();

                mthdIL.DeclareLocal(typeof(InvocationBase));
                mthdIL.DeclareLocal(baseClass);

                if (hasReturnValue)
                {
                    mthdIL.DeclareLocal(method.ReturnType);
                }

                if (hasParameters)
                {
                    mthdIL.DeclareLocal(typeof(Type[]));
                    mthdIL.DeclareLocal(typeof(object[])); 
                }

                mthdIL.Emit(OpCodes.Newobj, typeof(InvocationBase).GetConstructor(new Type[] { }));
                mthdIL.Emit(OpCodes.Stloc_0);
                
                mthdIL.Emit(OpCodes.Newobj, baseClass.GetConstructor(new Type[] { }));
                mthdIL.Emit(OpCodes.Stloc_1);

                mthdIL.Emit(OpCodes.Ldloc_0);
                mthdIL.Emit(OpCodes.Ldloc_1);
                mthdIL.Emit(OpCodes.Callvirt, typeof(InvocationBase).GetMethod("set_Owner", new Type[] { typeof(object) }));

                // get type of BaseClass
                mthdIL.Emit(OpCodes.Ldloc_0);
                mthdIL.Emit(OpCodes.Ldtoken, baseClass);
                mthdIL.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle", new Type[] { typeof(RuntimeTypeHandle) }));

                // Set method name
                mthdIL.Emit(OpCodes.Ldstr, method.Name);

                // define array Type[parameterInfos.Length]
                mthdIL.Emit(OpCodes.Ldc_I4, parameterInfos.Length);
                mthdIL.Emit(OpCodes.Newarr, typeof(Type));

                if (hasParameters)
                {
                    if (hasReturnValue)
                    {
                        mthdIL.Emit(OpCodes.Stloc_3);
                    }
                    else
                    {
                        mthdIL.Emit(OpCodes.Stloc_2);
                    }

                    // set elements
                    for (int i = 0; i < parameterInfos.Length; i++)
                    {
                        if (hasReturnValue)
                        {
                            mthdIL.Emit(OpCodes.Ldloc_3);
                        }
                        else
                        {
                            mthdIL.Emit(OpCodes.Ldloc_2);
                        }

                        //mthdIL.Emit(OpCodes.Dup);
                        mthdIL.Emit(OpCodes.Ldc_I4, i);
                        mthdIL.Emit(OpCodes.Ldtoken, parameterInfos[i].ParameterType);
                        mthdIL.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle", new Type[] { typeof(RuntimeTypeHandle) }));
                        mthdIL.Emit(OpCodes.Stelem_Ref);
                    }

                    if (hasReturnValue)
                    {
                        mthdIL.Emit(OpCodes.Ldloc_3);
                    }
                    else
                    {
                        mthdIL.Emit(OpCodes.Ldloc_2);
                    }
                }

                // call method: GetMethod(string, Type[])
                mthdIL.Emit(OpCodes.Call, typeof(Type).GetMethod("GetMethod", new Type[] { typeof(string), typeof(Type[]) }));

                // set InvocationBase.MethodInfo
                mthdIL.Emit(OpCodes.Callvirt, typeof(InvocationBase).GetMethod("set_MethodInfo", new Type[] { typeof(MethodInfo) }));

                // load InvocationBase
                mthdIL.Emit(OpCodes.Ldloc_0);

                // define array: object[]
                mthdIL.Emit(OpCodes.Ldc_I4, parameterInfos.Length);
                mthdIL.Emit(OpCodes.Newarr, typeof(object));

                if (parameterInfos.Length > 0)
                {
                    if (hasReturnValue)
                    {
                        mthdIL.Emit(OpCodes.Stloc_S, 4);
                    }
                    else
                    {
                        mthdIL.Emit(OpCodes.Stloc_3);
                    }

                    // set elements
                    for (int i = 0; i < parameterInfos.Length; i++)
                    {
                        if (hasReturnValue)
                        {
                            mthdIL.Emit(OpCodes.Ldloc_S, 4);
                        }
                        else
                        {
                            mthdIL.Emit(OpCodes.Ldloc_3);
                        }
                        
                        //mthdIL.Emit(OpCodes.Dup);
                        mthdIL.Emit(OpCodes.Ldc_I4, i);
                        mthdIL.Emit(OpCodes.Ldarg, i + 1);
                        mthdIL.Emit(OpCodes.Box, parameterInfos[i].ParameterType);
                        mthdIL.Emit(OpCodes.Stelem_Ref);
                    }

                    if (hasReturnValue)
                    {
                        mthdIL.Emit(OpCodes.Ldloc_S, 4);
                    }
                    else
                    {
                        mthdIL.Emit(OpCodes.Ldloc_3);
                    }
                }

                // set InvocationBase.ParameterValues
                mthdIL.Emit(OpCodes.Callvirt, typeof(InvocationBase).GetMethod("set_ParameterValues", new Type[] { typeof(object[]) }));

                // call _Interceptor.Intercept(invocationBase)
                mthdIL.Emit(OpCodes.Ldarg_0);
                mthdIL.Emit(OpCodes.Ldfld, fieldBuilder);
                mthdIL.Emit(OpCodes.Ldloc_0);
                mthdIL.Emit(OpCodes.Callvirt, typeof(IInterceptor).GetMethod("Intercept", new Type[] { typeof(IInvocation) }));

                // set return value
                if (method.ReturnType != typeof(void))
                {
                    // get return value from InvocationBase.ReturnValue
                    mthdIL.Emit(OpCodes.Ldloc_0);
                    mthdIL.Emit(OpCodes.Callvirt, typeof(InvocationBase).GetMethod("get_ReturnValue", new Type[0]));

                    // unbox return value
                    mthdIL.Emit(OpCodes.Unbox_Any, method.ReturnType);
                    mthdIL.Emit(OpCodes.Stloc_2);
                    mthdIL.Emit(OpCodes.Ldloc_2);
                }

                mthdIL.Emit(OpCodes.Ret);

                typeBuilder.DefineMethodOverride(methodBuilder, baseClass.GetMethod(method.Name, parameterInfos.Select(x => x.ParameterType).ToArray()));
            }

            var targetType = typeBuilder.CreateType();

            // DEBUG
            //_AssemblyBuilder.Save("auto.dll");

            return targetType;
        }

        
    }
}
